# Switchly

## Work Log

### Summary

```
24.08.2024 Saturday   2h 30m
25.08.2024 Sunday   4h


Total                6h 30m
```

### 25.08.2024 Sunday

**Focusing on the understanding the practial implementation of the vault acount creation and churn event**

During a key-generation/churn event, do we create a new vault with the new validator set added as signers then transfer the assets in? Or do we keep the existing vault and simply remove the validators that are being churned out from the signers list and add the churned in validators to the signers list?

Let's see how Thorchain does this!

Okay, [thorchain](https://gitlab.com/thorchain/thornode#churn) uses the former approach - create a new vault and move assets in there! Also uses the Genarro-Goldfeder Threshold Signature Scheme, which allows signing with no trusted party. Let's [read this paper](https://eprint.iacr.org/2020/540.pdf), should be insightful!

The GG TSS used in thorchain key-generation ceremony allows the nominated committee to construct the parameters for a new vault and the output is a public key from which the vault addresses for each chain is derived. Both secp256k1 and ed25519 chains are supported (Perfect! [Stellar is a ed25519 chain!](https://developers.stellar.org/docs/learn/encyclopedia/security/signatures-multisig)), and the vault address derivation is dependent on the chain.

Alright! that was a good read. I now have clarity of the possible approaches:
```txt
Approach 1 - Gennaro-Goldfeder TSS

Use Gennaro-Goldfeder TSS key-generation process on the Switchly protocol level. During each churn event, the nominated validators form a committee to construct a public key using this process. The constructed public key can then be used to derive vault addresses for each chain (including Stellar). Assets are moved into this new vault address.

The vault account on Stellar will be controlled by only one signer (the commitee of validators in the set) and a single signature generated by the Switchly validators in the GG TSS process will be the only signature that can facilitate a transaction from the vault. 

```

```txt
Approach 2 - Stellar Multisig

Use the Stellar native multisig mechanism to create an account. Account will be created by a leader (centralization worries) who becomes the master key by default. The leader adds on other signers (each validator in the committee). The leader removes and adds signers on each churn event.

```

Let's compare both approaches side-by-side

| Criteria | Gennaro-Goldfeder TSS | Stellar Multisig |
| :-------------------------------------- | :-------------: | :---------: |
| Trusted leader required to control master key | No | Yes |
| Number of signers added to the Stellar account | 1 | N - number of validators in the nominated committee |
| Upper limit on  possible threshold | No. [Supports any number of signers and any threshold value](https://eprint.iacr.org/2021/060) | Yes. Only a maximun of 20 signers can sign a transaction, otherwise it fails |
| Complexity | Less complex. The validators generate a single public key as a committee, which is then used to generate vault addresses across all supported chains | More complex and peculiar to Stellar only. Determining leadership can be a hassle with centralization concerns; and every validator on Switchly must have their own public key as signer on Stellar
| Cost efficiency | Highly cost efficient. Only one signer controls the Stellar account, so just a minimum balance of 0.5XLM must be maintained. Only pay for moving funds to a new vault address on each churn event | Less cost efficient. N number of validators will cost (0.5XLM * N) balance requirement. Also, on each churn event, there is the cost of adding N validators to the list of signers on the account and removing some in a transaction with multiple `Set Options` operations - more expensive!
| Computational  efficiency | Higher, as the vault public key is generated only once and used across multiple chains | Lower, as there's the need for determining leadership, adding and removing signers only on Stellar |
| Privacy | Yes. Partipating signers in a signing event are not revealed | No. Signers in a signing event are known publicly


Okay, I think the Gennaro-Goldfeder TSS approach is the right path forward. I will look into testing the vault creation and churn event next time, using this approach. I found a good developer library to work with [here](https://github.com/bnb-chain/tss-lib).


### 24.08.2024 Saturday

**Diving into Stellar-native signature options & appliacability to switchly**

**Summary:** ```Multisig appears to be ideal for the switchly use case. While Pre-authorized transaction and Hash(x) are great signature types, they seem to be unsuitable/inefficient/expensive for this use case - I think they are best suited for use cases requiring smaller quoroms and fewer outbound txs per hour, such as joint accounts & escrows.```


Stellar accounts can set their own signature weight, threshold values, and additional signing keys with the `Set Options` operation. This would be ideal for the switchly validators to control the vault account. Each validator will hold a signing key to the vault account. 

The threshold  on the vault account determines the requiered signature weight to authorize a transaction/operation. (e.g. payment operation).

The account will be created with a master key. Who controls the master key? should the master key weight be set to 0 weight to avoid centralization? if yes, what should be the order of event from account creation?

Okay, for a transaction/operation from the account to be successful, the sum of the weights of all signatures in the transaction must be greater than the threshold for that operation. Sounds like m of n threshold signature check going on here.


- Multisig

Interestingly, only 20 signatures can be attached to one transactions. If you have more signatures, it will fail even if they are all valid signatures! So we have a hard upper limit of `20 of n` signers in the validator set.

Another constraint is for each additional signer (other than the master key) the required minimun balance of the account increases by 0.5 XLM currently. This implies that if we have 50 validators for example, the vault account must hold at least 0.5 XLM * 50 = 25 XLM. Hmmm who pays for this? should each validator entering the set pay their share of total cost i.e. 0.5 XLM?

- Pre-authorized Transaction

A transaction that has been pre-constructed and validly pre-signed by the account signer(s), allowing any holder of the transaction to publish it to the network whenever they want - the sequence number must still be valid at that time tho.

You add the hash of a future transaction as a signer on the account. Once a matching transaction is sent to the network in future, the hash signer is removed from the account (regardless of whether the transaction succeeds or fails)... 

How will this play our practically? 
 1. Validators witness inbound txs on blockchain network X
 2. Validators come to a consesus on the ordering of the txs and the structure of equivalent txs to be settled on Stellar
 3. Any of the validator adds the hashes of the agreed settlement txs as signers to the vault account using the `Set Options` (expensive operation in time and $ - cost grows with the number of txs, and that's just at a point in time)
 4. Any of the validator broadcasts the txs to the validator in future. 

 Hmmm why do we need to presign a tx (by a comittee of validator) and broadcast same tx in future when we can sign (by the committee) and broadcast now? Sounds like ours isn't the right use case for pre-authorized transactions, which is more suitable to escrow type use cases.


- Hash(x) signature

Create x randomly, and generate hash(x) using SHA256. Then, add the hash as a signer to the vault account.

In a separate transaction (e.g. payment) you will add x as one of the signatures and submit to the network. At this point, x is known to the world and anyone who sees x on the network can sign tx for this vault account (wow!). Solution is to have more signers to ensure anyone who tries to use x independently will not have sufficeint weight to make a successful tx - haha sounds like we are doing multsig but in a hard way!


Okay! tomorrow, I will dive into multisig code implementation properly.
   